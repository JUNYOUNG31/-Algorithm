# 디저트 카페

# 친구들과 디저트 카페 투어를 할 계획이다.
# [Fig. 1]과 같이 한 변의 길이가 N인 정사각형 모양을 가진 지역에 디저트 카페가 모여 있다.
# 원 안의 숫자는 해당 디저트 카페에서 팔고 있는 디저트의 종류를 의미하고
# 카페들 사이에는 대각선 방향으로 움직일 수 있는 길들이 있다.
#
# 디저트 카페 투어는 어느 한 카페에서 출발하여
# [Fig. 2]와 같이 대각선 방향으로 움직이고 사각형 모양을 그리며 출발한 카페로 돌아와야 한다.
#
# 디저트 카페 투어를 하는 도중 해당 지역을 벗어나면 안 된다.
# 또한, 친구들은 같은 종류의 디저트를 다시 먹는 것을 싫어한다.
# 즉, [Fig. 3]과 같이카페 투어 중에 같은 숫자의 디저트를 팔고 있는 카페가 있으면 안 된다.
#
# 하나의 카페에서 디저트를 먹는 것도 안 된다.
# 왔던 길을 다시 돌아가는 것도 안 된다.
#
# 친구들과 디저트를 되도록 많이 먹으려고 한다.
# 디저트 가게가 모여있는 지역의 한 변의 길이 N과 디저트 카페의 디저트 종류가 입력으로 주어질 때,
# 임의의 한 카페에서 출발하여 대각선 방향으로 움직이고
# 서로 다른 디저트를 먹으면서 사각형 모양을 그리며 다시 출발점으로 돌아오는 경우,
# 디저트를 가장 많이 먹을 수 있는 경로를 찾고, 그 때의 디저트 수를 정답으로 출력하는 프로그램을 작성하라.
# 만약, 디저트를 먹을 수 없는 경우 -1을 출력한다.
#
# 입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T가 주어지고, 그 다음 줄부터 T개의 테스트 케이스가 주어진다.
# 각 테스트 케이스의 첫 번째 줄에는 디저트 카페가 모여있는 지역의 한 변의 길이 N이 주어진다.
# 그 다음 N 줄에는 N * N 크기의 디저트 카페에서 팔고 있는 디저트 종류에 대한 정보가 주어진다.

dr = [1, 1, -1, -1]                      # 우하 좌하 좌상 우상
dc = [1, -1, -1, 1]


def dfs(r, c, D, visited):                                      # dfs
    global ans                                                  # 최대 종류
    if cafe[r][c] in visited:                                   # 먹은 디저트면
        return                                                  # 멈춰
    else:                                                       # 안먹었으면
        visited.append(cafe[r][c])                              # 추가
    for d in range(D, 4):                                       # 방향을 현재 방향부터 돌리기
        nr = r + dr[d]
        nc = c + dc[d]
        if 0 <= nr < N and 0 <= nc < N:                         # 범위안에 있고
            if nr == start_r and nc == start_c:                 # 처음으로 돌아왔고
                if len(visited) < 4:                            # 사각형이 안되면
                    return                                      # 멈춰
                if d < 3:                                       # 방향전환이 3번이 안되면
                    return                                      # 멈춰
                # print(visited)
                ans.append(len(visited))                        # 정답에 총 먹은 디저트수 추가
                visited.pop()                                   # 마지막에 넣은거 pop 하고 이전 재귀로 넘어가서 방향 전환
                return                                          # 멈춰
            else:                                               # 원위치가 아니면
                dfs(nr, nc, d, visited)                         # 재귀
    visited.pop()                                               # 방향 다돌고도 안끝났으면 마지막꺼 팝하고 이전 재귀로 넘어가서 방향전환


T = int(input())                                                # case 입력
for tc in range(1, T+1):                                        # case 반복
    N = int(input())                                            # 크기
    cafe = [list(map(int, input().split())) for _ in range(N)]  # 카페입력
    ans = []                                                    # 정답 리스트
    for i in range(N):                                          # 전체 탐색
        for j in range(N):
            visited = []                                        # 먹엇는지 확인
            start_r = i                                         # 시작위치 저장
            start_c = j
            dfs(i, j, 0, visited)                               # 방향을 유지해야해서 d 도 넣음
    if len(ans) == 0:                                           # 정답리스트에 아무것도없으면
        print("#{} {}".format(tc, -1))                          # -1 반환
    else:                                                       # 있다면
        print("#{} {}".format(tc, max(ans)))                    # 최대값 반환