# 장훈이의 높은 선반

# 장훈이는 서점을 운영하고 있다. 서점에는 높이가 B인 선반이 하나 있는데 장훈이는 키가 매우 크기 때문에,
# 선반 위의 물건을 자유롭게 사용할 수 있다. 어느 날 장훈이는 자리를 비웠고, 이 서점에 있는 N명의 점원들이
# 장훈이가 선반 위에 올려놓은 물건을 사용해야 하는 일이 생겼다. 각 점원의 키는 Hi로 나타나는데, 점원들은
# 탑을 쌓아서 선반 위의 물건을 사용하기로 하였다.점원들이 쌓는 탑은 점원 1명 이상으로 이루어져 있다.
# 탑의 높이는 점원이 1명일 경우 그 점원의 키와 같고, 2명 이상일 경우 탑을 만든 모든 점원의 키의 합과 같다.
# 탑의 높이가 B 이상인 경우 선반 위의 물건을 사용할 수 있는데 탑의 높이가 높을수록 더 위험하므로 높이가 B
# 이상인 탑 중에서 높이가 가장 낮은 탑을 알아내려고 한다.

# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
# 각 테스트 케이스의 첫 번째 줄에는 두 정수 N, B(1 ≤ N ≤ 20, 1 ≤ B ≤ S)가 공백으로 구분되어 주어진다.
# S는 두 번째 줄에서 주어지는 점원들 키의 합이다.
# 두 번째 줄에는 N개의 정수가 공백으로 구분되어 주어지며, 각 정수는 각 점원의 키 Hi (1 ≤ Hi ≤ 10,000)을 나타낸다.


def comb(idx, s_idx):
    if s_idx == R:
        top(sel)
        return
    elif idx == N:
        return
    else:
        sel[s_idx] = arr[idx]
        comb(idx + 1, s_idx + 1)           # 해당 idx번째 자리를 뽑거나
        comb(idx + 1, s_idx)               # 해당 idx번째 자리를 뽑지않거나


def top(sel):                              # 탑높이 체크
    global ans
    hap = 0                                # 키의 합
    for i in sel:                          # 조합다돌려서
        hap += i                           # 각각의 키를 더해서
    if hap >= B:                           # 탑의 높이보다 크다면
        hap = hap-B                        # 그 차이만큼 저장
        if hap < ans:                      # 최솟값으로 계속 갱신
            ans = hap


T = int(input())                           # case 입력
for tc in range(1, T+1):                   # case 반복
    N, B = map(int, input().split())       # 점원 수 탑의 높이
    arr = list(map(int, input().split()))  # 점원들의 키
    ans = 210000                           # 최솟값
    for R in range(1, N+1):                # 조합구하기
        sel = [0] * R                      # 1개부터 N 개까지
        comb(0, 0)                         # 조합 돌리기
    print("#{} {}".format(tc, ans))